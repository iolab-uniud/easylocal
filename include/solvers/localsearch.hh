#pragma once

#include <iostream>
#include <fstream>
#include <string>
#include <typeinfo>
#include <atomic>

#include "helpers/solutionmanager.hh"
#include "runners/runner.hh"
#include "utils/parameter.hh"
#include "utils/interruptible.hh"

namespace EasyLocal
{

namespace Core
{

template <class Input, class Solution, class CostStructure = DefaultCostStructure<int>>
struct SolverResult
{
    SolverResult(const Solution &output) : output(output) {}
    SolverResult(const Solution &output, const CostStructure &cost, double running_time) : output(output), cost(cost), running_time(running_time) {}
    Solution output;
    CostStructure cost;
    double running_time;
};

/** A Local Search Solver has an internal state, and defines the ways for
 dealing with a local search algorithm.
 @ingroup Solvers
 */
template <class Input, class Solution, class CostStructure = DefaultCostStructure<int>>
class LocalSearch
: public CommandLineParameters::Parametrized,
public Interruptible<int>
{
public:
    /** These methods are the unique interface of Solvers */
    virtual SolverResult<Input, Solution, CostStructure> Solve() final;
    virtual SolverResult<Input, Solution, CostStructure> Resolve(const Solution &initial_solution) final;
    
    LocalSearch(const Input &in,
                        SolutionManager<Input, Solution, CostStructure> &e_sm,
                        std::string name);
    virtual std::shared_ptr<Solution> GetCurrentSolution() const;
    
protected:
    
    const Input& in;
    std::string name;
    virtual std::shared_ptr<Solution> GetCurrentState() const = 0;
    
    virtual ~LocalSearch()
    {}
    
    /** Implements Interruptible. */
    virtual std::function<int(void)> MakeFunction()
    {
        return [this](void) -> int {
            this->ResetTimeout();
            this->Go();
            return 1;
        };
    }
    
    virtual void TerminateSolve();
    virtual void FindInitialState();
    // This will be the actual solver strategy implementation
    virtual void Go() = 0;
    SolutionManager<Input, Solution, CostStructure> &sm;        /**< A pointer to the attached
                                                           state manager. */
    std::shared_ptr<Solution> p_current_state, p_best_state; /**< The internal states of the solver. */
    
    CostStructure current_state_cost, best_state_cost; /**< The cost of the internal states. */
    std::shared_ptr<Solution> p_out;                     /**< The output object of the solver. */
    // parameters
    
    Parameter<unsigned int> init_trials;
    Parameter<bool> random_initial_state;
    Parameter<double> timeout;
    std::atomic<bool> is_running;
    
private:
    void InitializeSolve();
};

/*************************************************************************
 * Implementation
 *************************************************************************/

/**
 @brief Constructs an abstract local search solver.
 
 @param in an input object
 @param sm a compatible state manager
 @param name a descriptive name for the solver
 */
template <class Input, class Solution, class CostStructure>
LocalSearch<Input, Solution, CostStructure>::LocalSearch(const Input &in,
                                                              SolutionManager<Input, Solution, CostStructure> &sm,
                                                              std::string name)
: CommandLineParameters::Parametrized(name, typeid(this).name()),
in(in), name(name), sm(sm), is_running(false)
{
    init_trials("init_trials", "Number of states to be tried in the initialization phase", this->parameters);
    random_initial_state("random_state", "Random initial state", this->parameters);
    timeout("timeout", "Solver timeout (if not specified, no timeout)", this->parameters);
    init_trials = 1;
    random_initial_state = true;
}



/**
 The initial state is generated by delegating this task to
 the state manager. The function invokes the SampleSolution function.
 */
template <class Input, class Solution, class CostStructure>
void LocalSearch<Input, Solution, CostStructure>::FindInitialState()
{
    if (random_initial_state)
        current_state_cost = sm.SampleState(*p_current_state, init_trials);
    else
    {
        sm.GreedyState(*p_current_state);
        current_state_cost = sm.CostFunctionComponents(*p_current_state);
    }
    *p_best_state = *p_current_state;
    best_state_cost = current_state_cost;
}

template <class Input, class Solution, class CostStructure>
void LocalSearch<Input, Solution, CostStructure>::InitializeSolve()
{
    p_best_state = std::make_shared<Solution>(this->in);
    p_current_state = std::make_shared<Solution>(this->in);
}

template <class Input, class Solution, class CostStructure>
SolverResult<Input, Solution, CostStructure> LocalSearch<Input, Solution, CostStructure>::Solve()
{
    auto start = std::chrono::high_resolution_clock::now();
    is_running = true;
    InitializeSolve();
    FindInitialState();
    if (timeout.IsSet())
        SyncRun(std::chrono::milliseconds(static_cast<long long int>(timeout * 1000.0)));
    else
        Go();
    p_out = std::make_shared<Solution>(this->in);
    *p_out = *p_best_state;
    TerminateSolve();
    
    double run_time = std::chrono::duration_cast<std::chrono::duration<double, std::ratio<1>>>(std::chrono::high_resolution_clock::now() - start).count();
    is_running = false;
    
    return SolverResult<Input, Solution, CostStructure>(*p_out, sm.CostFunctionComponents(*p_best_state), run_time);
}

template <class Input, class Solution, class CostStructure>
SolverResult<Input, Solution, CostStructure> LocalSearch<Input, Solution, CostStructure>::Resolve(const Solution &initial_solution)
{
    auto start = std::chrono::high_resolution_clock::now();
    is_running = true;
    
    InitializeSolve();
    *p_current_state = initial_solution;
    *p_best_state = *p_current_state;
    best_state_cost = current_state_cost = sm.CostFunctionComponents(*p_current_state);
    if (timeout.IsSet())
        SyncRun(std::chrono::milliseconds(static_cast<long long int>(timeout * 1000.0)));
    else
        Go();
    p_out = std::make_shared<Solution>(this->in);
    *p_out = *p_best_state;
    TerminateSolve();
    is_running = false;
    
    // TODO: review the following
    double run_time = std::chrono::duration_cast<std::chrono::duration<double, std::ratio<1>>>(std::chrono::high_resolution_clock::now() - start).count();
    
    return SolverResult<Input, Solution, CostStructure>(*p_out, sm.CostFunctionComponents(*p_best_state), run_time);
}

template <class Input, class Solution, class CostStructure>
void LocalSearch<Input, Solution, CostStructure>::TerminateSolve()
{}

template <class Input, class Solution, class CostStructure>
std::shared_ptr<Solution> LocalSearch<Input, Solution, CostStructure>::GetCurrentSolution() const
{
    //std::shared_ptr<Solution> current_state;
    // if (!is_running)
    //     current_state = this->p_best_state;
    // else
    //     current_state = GetCurrentState();
    //current_state = this->p_current_state;
    std::shared_ptr<Solution> out = std::make_shared<Solution>(this->in);
    *out = *(GetCurrentState());
    return out;
}
} // namespace Core
} // namespace EasyLocal
