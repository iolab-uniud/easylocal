#ifndef LOCALSEARCHSOLVER_HH_
#define LOCALSEARCHSOLVER_HH_

#include "Solver.hh"
#include "../helpers/StateManager.hh"
#include "../helpers/OutputManager.hh"
#include <iostream> 
#include <fstream> 
#include <string>

/** A Local Search Solver has an internal state, and defines the ways for
dealing with a local search algorithm.
@ingroup Solvers
*/
template <class Input, class Output, class State, typename CFtype = int>
class LocalSearchSolver
: public Solver<Input, Output>
{
public:
  void SetInitTrials(unsigned int t);
  void Solve() throw(EasyLocalException);
  void ReSolve() throw(EasyLocalException);
  void MultiTrialSolve(unsigned int n) throw(EasyLocalException);
  virtual void Check() const throw(EasyLocalException);
  CFtype GetCost() const;
  const Output& GetOutput();
  const State& GetState() const;
  void SetState(const State& st, CFtype cost);
  void SetState(const State& st);
  void SetState(const Output& out);
  virtual void ReadParameters(std::istream& is = std::cin, std::ostream& os = std::cout) = 0;
protected:
    LocalSearchSolver(const Input& in,
                      StateManager<Input,State,CFtype>& e_sm,
                      OutputManager<Input,Output,State,CFtype>& e_om,
                      const std::string& name = "");
  /**
    Lets all the managed runners Go, and then it collects the best state
   found.
   */
  virtual void Run() = 0;
  
  /** Performs some checking before making a run of the solver,
    if something goes wrong it raises an exception. */
  virtual void FindInitialState();
  StateManager<Input,State,CFtype>& sm; /**< A pointer to the attached
    state manager. */
  OutputManager<Input,Output,State,CFtype>& om; /**< A pointer to the attached
    output manager. */
  CFtype internal_state_cost;  /**< The cost of the internal state. */
  State internal_state;        /**< The internal state of the solver. */
  unsigned int number_of_init_trials; /**< Number of different initial
    states tested for a run. */
  Output out;
};

/*************************************************************************
* Implementation
*************************************************************************/

/**
Constructs a local search solver by providing it a state manager,
 an output manager, an input object, and an output object.
 
 @param sm a pointer to a compatible state manager
 @param om a pointer to a compatible output manager
 @param in a pointer to an input object
 @param out a pointer to an output object
 */
template <class Input, class Output, class State, typename CFtype>
LocalSearchSolver<Input,Output,State,CFtype>::LocalSearchSolver(const Input& in,
                                                         StateManager<Input,State,CFtype>& e_sm,
                                                         OutputManager<Input,Output,State,CFtype>& e_om, const std::string& name)
: Solver<Input, Output>(in), sm(e_sm),  om(e_om), internal_state(in),
number_of_init_trials(1), out(in)
{ EasyLocalObject::SetName(name); }

template <class Input, class Output, class State, typename CFtype>
const State& LocalSearchSolver<Input,Output,State,CFtype>::GetState() const
{ return internal_state; }

template <class Input, class Output, class State, typename CFtype>
CFtype LocalSearchSolver<Input,Output,State,CFtype>::GetCost() const
{ return internal_state_cost; }

template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::SetState(const State& st)
{
	internal_state = st;
	internal_state_cost = sm.CostFunction(internal_state); 
}

template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::SetState(const State& st, CFtype cost)
{
	internal_state = st;
	internal_state_cost = cost; 
}

template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::SetState(const Output& out)
{
  om.InputState(internal_state,out);
  internal_state_cost = sm.CostFunction(internal_state); 
}

/**
Set the number of states which should be tried in 
 the initialization phase.
 */
template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::SetInitTrials(unsigned int t)
{
  number_of_init_trials = t;
}

/**
The output is delivered by converting the final internal state
 to an output object by means of the output manager.
 */
template <class Input, class Output, class State, typename CFtype>
const Output& LocalSearchSolver<Input,Output,State,CFtype>::GetOutput() 
{
  om.OutputState(internal_state, out);
  return out;
}

/**
The initial state is generated by delegating this task to 
 the state manager. The function invokes the SampleState function.
 */
template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::FindInitialState()
{
  internal_state_cost = sm.SampleState(internal_state, number_of_init_trials);
}

/**
Checks wether the object state is consistent with all the related
 objects.
 */
template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::Check() const
throw(EasyLocalException)
{}

/**
Performs a full solving procedure by finding an initial state, 
 running the attached runner and delivering the output.
 */
template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::Solve()
throw(EasyLocalException)
{
  //  Check();
  FindInitialState();
  Run();
}

/**
Start again a solving procedure, running the attached runner from
 the current internal state.
 */
template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::ReSolve()
throw(EasyLocalException)
{
  //  Check();
  Run();
}

/**
Tries multiple runs on different initial states and records the
 best one.
 
 @param n the number of trials
 */
template <class Input, class Output, class State, typename CFtype>
void LocalSearchSolver<Input,Output,State,CFtype>::MultiTrialSolve(unsigned int n)
throw(EasyLocalException)
{
  State best_state(this->in);
  CFtype best_state_cost = 0; // value set just to prevent warning from smart compilers
  
  for (unsigned int i = 0; i < n; i++)
  {
    FindInitialState();
    Run();
    
    if (i == 0 || internal_state_cost < best_state_cost)
    {
      best_state = internal_state;
      best_state_cost = internal_state_cost;
    }
  }
  internal_state = best_state;
  internal_state_cost = best_state_cost;
}

#endif /*LOCALSEARCHSOLVER_HH_*/
