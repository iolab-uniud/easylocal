#if !defined(_ABSTRACT_LOCAL_SEARCH_HH_)
#define _ABSTRACT_LOCAL_SEARCH_HH_

#include <solvers/Solver.hh>
#include <helpers/StateManager.hh>
#include <helpers/OutputManager.hh>
#include <runners/Runner.hh>
#include <iostream> 
#include <fstream> 
#include <string>

/** A Local Search Solver has an internal state, and defines the ways for
    dealing with a local search algorithm.
    @ingroup Solvers
*/
template <class Input, class Output, class State, typename CFtype = int>
class AbstractLocalSearch
  : public Solver<Input, Output>
{
public:
  void SetInitTrials(unsigned int t);
  CFtype GetCurrentCost() const;
  CFtype GetBestCost() const;
  const Output& GetOutput();
  const State& GetCurrentState() const;
  const State& GetBestState() const;
  virtual void SetCurrentState(const State& st, CFtype cost);
  virtual void SetCurrentState(const State& st);
  virtual void ReadParameters(std::istream& is = std::cin, std::ostream& os = std::cout) = 0;
protected:
  AbstractLocalSearch(const Input& in,
		      StateManager<Input,State,CFtype>& e_sm,
		      OutputManager<Input,Output,State,CFtype>& e_om,
		      std::string name);
  /** Performs some checking before making a run of the solver,
      if something goes wrong it raises an exception. */
  virtual void FindInitialState(bool random_state = true);
  StateManager<Input,State,CFtype>& sm; /**< A pointer to the attached
					   state manager. */
  OutputManager<Input,Output,State,CFtype>& om; /**< A pointer to the attached
						   output manager. */
  CFtype current_state_cost, best_state_cost;  /**< The cost of the internal states. */
  State current_state, best_state;        /**< The internal states of the solver. */
  unsigned int number_of_init_trials; /**< Number of different initial
					 states tested for a run. */
  Output out;
protected:
};

/*************************************************************************
 * Implementation
 *************************************************************************/

/**
   @brief Constructs an abstract local search solver.
  
   @param in an input object
   @param e_sm a compatible state manager
   @param e_om a compatible output manager
   @param name a descriptive name for the solver
*/
template <class Input, class Output, class State, typename CFtype>
AbstractLocalSearch<Input,Output,State,CFtype>::AbstractLocalSearch(const Input& in,
								    StateManager<Input,State,CFtype>& e_sm,
								    OutputManager<Input,Output,State,CFtype>& e_om,  
								    std::string name)
  : Solver<Input, Output>(in, name), sm(e_sm),  om(e_om), current_state(in), best_state(in),
    number_of_init_trials(1), out(in)
{}

template <class Input, class Output, class State, typename CFtype>
const State& AbstractLocalSearch<Input,Output,State,CFtype>::GetCurrentState() const
{ return current_state; }

template <class Input, class Output, class State, typename CFtype>
CFtype AbstractLocalSearch<Input,Output,State,CFtype>::GetCurrentCost() const
{ return current_state_cost; }

template <class Input, class Output, class State, typename CFtype>
const State& AbstractLocalSearch<Input,Output,State,CFtype>::GetBestState() const
{ return best_state; }

template <class Input, class Output, class State, typename CFtype>
CFtype AbstractLocalSearch<Input,Output,State,CFtype>::GetBestCost() const
{ return best_state_cost; }

template <class Input, class Output, class State, typename CFtype>
void AbstractLocalSearch<Input,Output,State,CFtype>::SetCurrentState(const State& st)
{
  current_state = st;
  current_state_cost = sm.CostFunction(current_state); 
}

template <class Input, class Output, class State, typename CFtype>
void AbstractLocalSearch<Input,Output,State,CFtype>::SetCurrentState(const State& st, CFtype cost)
{
  current_state = st;
  current_state_cost = cost; 
}

/**
   Set the number of states which should be tried in 
   the initialization phase.
*/
template <class Input, class Output, class State, typename CFtype>
void AbstractLocalSearch<Input,Output,State,CFtype>::SetInitTrials(unsigned int t)
{
  number_of_init_trials = t;
}

/**
   The output is delivered by converting the best state
   to an output object by means of the output manager.
*/
template <class Input, class Output, class State, typename CFtype>
const Output& AbstractLocalSearch<Input,Output,State,CFtype>::GetOutput() 
{
  om.OutputState(best_state, out);
  return out;
}

/**
   The initial state is generated by delegating this task to 
   the state manager. The function invokes the SampleState function.
*/
template <class Input, class Output, class State, typename CFtype>
void AbstractLocalSearch<Input,Output,State,CFtype>::FindInitialState(bool random_state)
{
  if (random_state)
    current_state_cost = sm.SampleState(current_state, number_of_init_trials);
  else
    {
      sm.GreedyState(current_state);
      current_state_cost = sm.CostFunction(current_state);
    }
}

#endif // _ABSTRACT_LOCAL_SEARCH_HH_
